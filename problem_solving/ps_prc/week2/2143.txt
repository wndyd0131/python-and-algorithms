문제: 두 배열의 합 (2143)

결론: 두 배열의 합이 T인 경우의 수를 출력
T: 결과값
n: 배열A의 수
m: 배열B의 수

----------------
각 A와 B배열의 합을 누적시켜서, 각각의 합이 T가 되는 경우를 찾으면 되기 때문에 브루트포스를 사용해서 모두 처리해볼 수도 있지만,
그러기엔 각각 최대 1000개인 데이터를 O(n^2)으로 돌려야 할테니, 시간초과가 날 수 있음을 알 수 있다.

이렇게 데이터가 많을 경우 binary search를 쓰기 좋은데, 정렬시킬 수 있는 상태이기 때문에 binary search 사용가능임을 알 수 있다.

그래서 원래는 binary search로 아래와 같이 구현했는데:

def bs(idx, start, end):
    global cnt
    if start > end:
        return None

    mid = (start + end) // 2
    if A[idx] + B[mid] > T:
        bs(idx, start, mid-1)
    elif A[idx] + B[mid] < T:
        bs(idx, mid+1, end)
    else:
        cnt += B.count(B[mid])

A[i]와 B[mid]의 합이 T보다 크면 더 작은 B값을 A와 더해야하는 것이기 때문에 left_bound를, 작으면 더 큰 값을 더해야하는 것이기 때문에 right_bound로 넘어가게 함
    -> 예제의 경우는 맞지만, 코너 케이스에서 뭐가 잘못된 것인지 결과는 틀렸습니다로 뜸


결국 풀이봄
->
딕셔너리A와 딕셔너리B 각각에 부분합에 대한 개수를 저장함
A: [1,2,3,1,2] B: [3, 5, 1, 2]
A{1: 2, 2: 2, 3: 1}
B{1: 1, 2: 2, 3: 1, 5: 1}

A{}에 대해 루프를 돌면서 (T - A.key)가 B 안에 존재하는지 확인 -> 존재할 시 A.key + B.key == T 인 것이기 때문에 두 배열의 합이 성립함
    -> 성립할 경우 각각의 값의 개수를 서로 곱한 걸 누적시킴
        - 어차피 T를 이룰 때 A에 대해서 정해진 값은 하나 (예를 들어 1이면 5를 이루기 위해 반드시 4가 오게 되어 있음)이기 때문에 중복된 개수만큼 서로 곱해줌
    -> cnt += A.value * B.value

결과: 정답
    - 이진탐색은 아니지만, 개수를 저장하여 데이터에 대한 접근을 많이 줄이기 때문에 효율적인 것 같음