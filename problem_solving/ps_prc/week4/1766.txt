접근1:
- 우선순위
    1) 단순 쉬운 문제
    2) 쉬운 문제보다 먼저 풀어야 좋은 문제
    3) 먼저 풀어야 좋은 문제


순서가 안정해진건 맨 마지막에 정렬

3 2
5 3
6 5
로 가정하면 6부터 해야 됨

먼저 풀면 좋은게 있는 친구 / 없는 친구
로 분류

접근2:

핵심: 가장 쉬운 것을 풀되, 현재 풀 수 있는 문제부터 푼다

힙
- 완전 이진트리
- 삽입: 마지막 노드에 삽입한 뒤, 위로 비교하면서 올라옴
- 삭제: 루트 노드를 삭제한 뒤, 마지막 노드를 루트 노드에 임시로 삽입하고 제자리를 찾아가도록 계속 연산함

우선순위 큐
- 리스트로 구현 가능
    - 간단하지만 삽입 = O(1), 삭제 = O(N)
- 힙으로 구현 가능
    - 복잡하지만 삽입 = O(logN), 삭제 = O(logN)


위상 정렬
- 순서가 정해진 작업을 차례대로 수행할 때 사용하는 알고리즘
- 사이클이 존재한다면 해당 알고리즘을 사용할 수 없음 (DAG(Directed Acyclic Graph)일 때만 사용가능)

    1) 진입차수가 0인 정점을 큐에 삽입
    2) 큐에서 꺼내고 해당 정점과 연결된 간선을 모두 제거
    3) 제거했을 때 0인 정점을 모두 큐에 삽입
    4) 2~3을 반복

        - 이로써, 큐에서 꺼낸 결과가 위상정렬의 결과가 됨

그래프
- graph = []
    - 2와 1을 연결...

해당 문제에서
    - 먼저 풀면 좋은 문제를 위상 정렬을 통해 값끼리 연결 지음
    - 가장 쉬운 문제를 먼저 풀어야 되기 때문에 진입차수가 0인 경우를 우선순위 큐에 넣고, 이후에 하나씩 빼면서 간선을 제거해줌으로써 특정값의 진입차수를 0으로 만듦
        - 한 단계마다 진행이 되기 때문에 반드시 진입차수가 0이 되는 경우가 발생해서 끝날 때서야 큐가 비게 됨