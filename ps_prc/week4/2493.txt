문제: 탑
메모리 제한: 128MB
시간 제한: 1.5초

접근1:
    구현 방법:
        - 구현을 해보면 로직 자체가 어려운 문제는 아닌 것을 알 수 있음
            - 오른쪽에서부터 왼쪽으로 루프를 돌리면서 i보다 j가 큰 경우 바로 스택에 넣고 break 걸고, 하나씩 pop시켜서 출력해주면 됨

    해당 구현 방식의 문제점:
        - 최악의 경우 O(N^2)?이기 때문에 500000^2?번 푸쉬하게 되는데, 시간 초과 발생함
            - 즉, 데이터 접근 횟수를 줄여야 함


해당 문제로 인해 얻은 정보:
    - 방향이 정해진 문제의 경우, 반대 방향을 통한 접근도 고려해보자


6 9 5 7 4
0 0 2 2 4

6 9 8 7 4
0 0 2 3 4

왼쪽에 지보다 큰 값이 있으면 멈춤


접근2:
    풀이를 힌트겸 참고해서 다시 풀어봄
    - 아이디어: 왼쪽부터 우측까지 루프를 돌면서 다음값과 비교해서 다음값이 더 작을 경우 다음값은 현재값과 부딪히기 때문에 현재값 스택에 넣음,
        반대로 클 경우에는 최대값에 부딪히거나 안 부딪히기 때문에 최대값과 비교 시 다음값이 더 작은지 큰지로 나눔
        최대값을 [최대값,최대값인덱스] 형태로 저장하고
        루프를 돌 때:
            현재값 >= 다음값
                - 현재 인덱스 스택에 넣음
            현재값 < 다음값
                - 최대값과 다음값 비교후 더 작으면 최대값 인덱스 스택에 넣음
                - 최대값과 다음값 비교후 더 크면 최대값 교체 후 0을 스택에 넣음
        이렇게 하면 O(N)의 시간복잡도로 할 수 있음

    - 결과:
        - 틀렸습니다
    - 원인:
        - 설계 오류
            최대값을 기준으로 하여,
                9 6 4 5 1과 같은 input이 오면 5가 6이 아닌 9를 향해 쏘게 되어 잘못된 값이 출력됨
    - 해결법:
        - 스택에 후보를 푸쉬하고, 스택의 탑보다 큰값이 오면 그 값이 탑의 값보다 작을 때까지 팝
            