문제: 탑
메모리 제한: 128MB
시간 제한: 1.5초

접근1:
    아이디어:
        - 구현을 해보면 로직 자체가 어려운 문제는 아닌 것을 알 수 있음
            - 오른쪽에서부터 왼쪽으로 루프를 돌리면서 i보다 j가 큰 경우 바로 스택에 넣고 break 걸고, 하나씩 pop시켜서 출력해주면 됨
    구현: 생략
    
    결과: 시간 초과

    문제점:
        - 최악의 경우 O(N^2)?이기 때문에 500000^2?번 푸쉬하게 되는데, 시간 초과 발생함
            - 즉, 데이터 접근 횟수를 줄여야 함


    해당 문제로 인해 얻은 정보:
      - 방향이 정해진 문제의 경우, 반대 방향을 통한 접근도 고려해보자

접근2:
    풀이를 힌트겸 참고해서 다시 풀어봄
    - 아이디어: 왼쪽부터 우측까지 루프를 돌면서 다음값과 비교해서 다음값이 더 작을 경우 다음값은 현재값과 부딪히기 때문에 현재값 스택에 넣음,
        반대로 클 경우에는 최대값에 부딪히거나 안 부딪히기 때문에 최대값과 비교 시 다음값이 더 작은지 큰지로 나눔
        최대값을 [최대값,최대값인덱스] 형태로 저장하고
        루프를 돌 때:
            현재값 >= 다음값
                - 현재 인덱스 스택에 넣음
            현재값 < 다음값
                - 최대값과 다음값 비교후 더 작으면 최대값 인덱스 스택에 넣음
                - 최대값과 다음값 비교후 더 크면 최대값 교체 후 0을 스택에 넣음
        이렇게 하면 O(N)의 시간복잡도로 할 수 있음

    - 결과:
        - 틀렸습니다
    - 원인:
        - 설계 오류
            최대값만을 기준으로 하여,
                9 6 4 5 1과 같은 input이 오면 5가 6이 아닌 9를 향해 쏘게 되어 잘못된 값이 출력됨
  
접근3:
  - 아이디어: 왼쪽부터 루프를 돌려서, 스택탑의 값과 비교를 하는 아이디어
    *스택은 신호를 받을 수도 있는 후보들
  
    - 각 입력에 대해 while 루프로 스택이 존재할 때까지:
      - 현재값보다 스택탑값이 더 작으면 스택탑값은 이후로 신호를 받지 못할 값이기 때문에 pop
      - 그러다가 현재값보다 스택탑값이 더 클 때 멈춘 뒤 현재값을 스택에 push [스택탑의 인덱스 출력]
    - 스택이 비게 되면 신호를 받을 수 있는 후보가 없는 걸 뜻하여 0을 push [0을 출력]

    - 즉: 
        |
        |   |
        | | |

        - 여기서 2번째 탑은 이후로 신호를 받을 가능성이 없는 친구라

        |
        | |
        | |

        - 그냥 두고 필요한 애들만 스택에 넣어주면서 O(N)으로 접근하는 셈

  - 결과: 성공