문제: Z
메모리 제한: 512MB
시간 제한: 0.5초

결론: N일 때 r, c에 몇 번째로 방문 했는지 출력

알고리즘: 분할정복
- 알고리즘을 아는 상태로 접근한 거지만, 반복적인 문제가 작은 틀에서부터 큰 틀까지 존재하니,
큰 문제를 분할해서 작은 문제로 나누어 푸는게 적합하기 때문에 분할정복의 접근이 알맞는 것을 알 수 있다

접근:
1) 어떻게 Z 모양을 그릴까?
각 네모의 시작점:
N이 1일 때: (0,0) (0,1) (1,0) (1,1)
N이 2일 때: (0,0) (0,2) (2,0) (2,2)
N이 3일 때: (0,0) (0,4) (4,0) (4,4)
N이 4일 때: (0,0) (0,8) (8,0) (8,8)
N이 1일 때에는: 2^1 x 2^1 그래프
N이 2이상일 때에는: 2^N-1 x 2^N-1 그래프

접근1:
0일 때: (0,0) 등.. 개인 접근
  - cnt += 1
1일 때: (0,0) (0,1) (1,0) (1,1)
-> 그리고 리턴
2일 때: 다시 (0,2)로 접근해서 1일 때의 작업을 한다
  - (0,0)로 접근하면 (0,0) (0,2) (2,0) (2,2)
  - (0,2)로 접근하면 (0,2) (0,3) (1,2) (1,3)
  - (2,0)로 접근하면 (2,0) (2,1) (3,0) (3,1)
-> 다 하면 리턴
3일 때: 다시 (0,4)로 접근해서 2로 가고 1로 가서 1의 작업을 수행
  - (0,0)로 접근하면 (0,0) (0,4) (4,0) (4,4)
재귀 끝나면 끝

결론: 재귀적으로 함수 콜해서 0일 때 카운트 해주고, arr[r][c]가 view됐으면 return 하여 이후의 접근에서는 cnt 안 오름

  - n = 0이 될 때까지 재귀적으로 
    func(x,y,n-1)
    func(x,y+num,n-1)
    func(x+num,y,n-1)
    func(x+num,y+num,n-1)
    
    
    각 시작 위치 + num에 대한 패턴에 대해 돌리면 n-1씩 내리면서 결국 4개의 엘리먼트에 접근하게 됨
    0 되면 cnt += 1


처음에 마주친 벽: 어떻게 x,y일 때까지만 count를 할까?
  - x,y일 때 멈춰야 하는데, x,y일 때 멈추려면 함수 자체가 끝나야 함

  - 해결: 처음에 재귀를 n=1까지만 했는데, 이 경우 4개의 값에 모두 접근해야돼서 하나의 값이 return 조건에 해당된다고 해서 멈출 수 있는 구조가 아니란걸 깨달음
      - 그래서 그냥 n=0까지 하니까 개인적으로 접근이 가능해서 데이터에 접근 시 r,c가 이미 1인경우 그냥 return하도록 함

  - 결과:
    - 메모리초과
    - 이유를 생각해보니 512MB는 5억, 2^15 x 2^15는 10억이니, N이 15인 경우 메모리 제한에 걸림

접근2:
  - 메모리초과를 단순히 배열 할당의 문제로 생각해서 배열을 사용하지 않고 접근을 해봤다
  결과:
    - 메모리초과
    - 보아하니 배열이 아닌 재귀호출로 인한 스택오버플로우 같다
      - 재귀호출의 횟수를 줄여야 되는 거 같음

접근3:
  - 풀이를 보고 알아낸 문제점
    - 아무 조건 없이 계속 돌린 것으로 보아 재귀호출로 최악의 경우 10억번을 돌기 때문에 브루트포스랑 다를 바 없음
    - 해결법: 횟수를 줄이기 위해 범위에 속하지 않는 경우 2^N^N 만큼 cnt를 올림, 이를 2x2가 될때까지 진행하고, 2x2일 때 각각의 인덱스와 r,c를 비교해서 경우에 따라 출력
      - 예를 들어 N이 3일 때, N이 2로 줄어들면서 2^N = 4 -> 하나의 네모가 4x4의 숫자를 갖기 때문에 4x4를 해줘서 cnt를 올림
