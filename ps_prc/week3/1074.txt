문제: Z
메모리 제한: 512MB
시간 제한: 0.5초

결론: N일 때 r, c에 몇 번째로 방문 했는지 출력

알고리즘: 분할정복
- 알고리즘을 아는 상태로 접근한 거지만, 반복적인 문제가 작은 틀에서부터 큰 틀까지 존재하니,
큰 문제를 분할해서 작은 문제로 나누어 푸는게 적합하기 때문에 분할정복의 접근이 알맞는 것을 알 수 있다

접근:
1) 어떻게 Z 모양을 그릴까?
각 네모의 시작점:
N이 1일 때: (0,0) (0,1) (1,0) (1,1)
N이 2일 때: (0,0) (0,2) (2,0) (2,2)
N이 3일 때: (0,0) (0,4) (4,0) (4,4)
N이 4일 때: (0,0) (0,8) (8,0) (8,8)
N이 1일 때에는: 2^1 x 2^1 그래프
N이 2이상일 때에는: 2^N-1 x 2^N-1 그래프

접근1:
0일 때: (0,0) 등.. 개인 접근
  - cnt += 1
1일 때: (0,0) (0,1) (1,0) (1,1)
-> 그리고 리턴
2일 때: 다시 (0,2)로 접근해서 1일 때의 작업을 한다
  - (0,0)로 접근하면 (0,0) (0,2) (2,0) (2,2)
  - (0,2)로 접근하면 (0,2) (0,3) (1,2) (1,3)
  - (2,0)로 접근하면 (2,0) (2,1) (3,0) (3,1)
-> 다 하면 리턴
3일 때: 다시 (0,4)로 접근해서 2로 가고 1로 가서 1의 작업을 수행
  - (0,0)로 접근하면 (0,0) (0,4) (4,0) (4,4)
재귀 끝나면 끝

결론: 재귀적으로 함수 콜해서 0일 때 카운트 해주고, arr[r][c]가 view됐으면 return 하여 이후의 접근에서는 cnt 안 오름

  - n = 0이 될 때까지 재귀적으로 
    func(x,y,n-1)
    func(x,y+num,n-1)
    func(x+num,y,n-1)
    func(x+num,y+num,n-1)
    
    
    각 시작 위치 + num에 대한 패턴에 대해 돌리면 n-1씩 내리면서 결국 4개의 엘리먼트에 접근하게 됨
    0 되면 cnt += 1


처음에 마주친 벽: 어떻게 x,y일 때까지만 count를 할까?
  - x,y일 때 멈춰야 하는데, x,y일 때 멈추려면 함수 자체가 끝나야 함

  - 해결: 처음에 재귀를 n=1까지만 했는데, 이 경우 4개의 값에 모두 접근해야돼서 하나의 값이 return 조건에 해당된다고 해서 멈출 수 있는 구조가 아니란걸 깨달음
      - 그래서 그냥 n=0까지 하니까 개인적으로 접근이 가능해서 데이터에 접근 시 r,c가 이미 1인경우 그냥 return하도록 함

  - 결과:
    - 메모리초과